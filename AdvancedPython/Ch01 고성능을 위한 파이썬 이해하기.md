# Chapter 1. 고성능을 위한 파이썬 이해하기
```
이 장에서 배울 내용
- 컴퓨터의 구성 요소
- 컴퓨터 구성 요소의 다양한 종류
- 파이썬에서 컴퓨터 구성 요소를 추상화하는 방법
- 고성능을 위한 파이썬 코드를 작성할 때 넘어야 할 장벽
- 성능 관련 문제의 종류
```

### Computer programming
어떤 결과를 도출하기 위해 특별한 방법으로 데이터를 가공해서 주고받는 과정
- 부하를 최소화(더 효과적인 코드를 작성)
- 각 단계에 더 적합한 방법(알고리즘, 구조 등)을 찾아 변경
- 위 작업에는 상당한 시간이 소요

우선 코드에서 부하를 줄이는 데 집중, **실제로 데이터를 주고받는 하드웨어에 대한 더 깊은 통찰을 얻어보자!**
- 파이썬은 하드웨어와의 상호작용을 추상화해서 숨기는 것에 꽤나 열심.. 쉽지 않은 연습이 될 것

## 1.1 컴퓨터 시스템의 기본
컴퓨터 구성 요소
- 연산 장치: 초당 계산할 수 있는 처리량
- 기억 장치: 얼마나 많은 데이터를 저장할 수 있는지, 얼마나 빠르게 데이터를 읽고 쓸 수 있는지
- 연결 장치: 데이터를 얼마나 빠르게 옮길 수 있는지

### [연산 장치(Arithmetic and Logic Unit, ALU)](http://blog.naver.com/PostView.nhn?blogId=sealriel&logNo=10110468141)
입력받은 비트를 다른 비트로 변환하거나 프로세스의 상태를 변경

CPU/GPU(고유의 병렬적인 특성으로 동시에 많은 데이터 처리 가능)

연산 장치는 종류에 관계없이 여러 비트를 입력받아 다른 비트의 조합으로 변환

정수와 실수의 산술 연산과 이진수의 비트 연산 기능 제공!

연산 장치의 주요 속성은
- 한 사이클에 처리할 수 있는 연산의 수
    - IPC(instruction per cycle)로 측정
- 1초에 처리할 수 있는 사이클의 횟수
    - clock 속도로 측정

```
IPC와 clock 속도는 연산 장치를 비교할 때 경쟁적으로 언급
ex) 인텔 코어 시리즈 IPC high bug clock 속도가 상대적으로 떨어짐
    펜티엄4는 그 반대

    GPU는 매우 높은 clock 속도와 IPC값을 가지지만 다른 문제가 발목을 잡음
```

SIMD(Single Instruction, Multi Data)
- 클럭 속도 상승 -> 초당 수행할 수 있는 연산량 상승 -> 그 연산 장치를 사용하는 모든 프로그램의 속도가 바로 개선
- IPC 값 상승 -> 벡터화 수준 증가 -> 처리 성능 급격히 상승
    - 벡터화: CPU가 여러 개의 데이터를 입력받아 한 번에 처리하는 것

클럭 속도와 IPC의 향상은 **트렌지스터**를 작게 만들어야 한다는 제약으로 정체

때문에 CPU 제조사는 더 빠른 속도를 얻기 위해
- HyperThreading
- Out-of-order execution
- multicore architecture와 같은 다른 방법을 모색

**HyperThreading, 하이퍼스레딩**
운영체제가 가상의 두 번째 CPU를 인식하게 한 다음, 똑똑한 하드웨어 로직이 단일 CPU의 실행 유닛에 두 스레드를 섞어 실행하도록 하는 기법
- 잘만 작동하면 단일 스레드 대비 30%까지 성능을 끌어올릴 수 있다
- 한 스레드가 실수 연산을 하고 다른 스레드가 정수 연산을 한다면 잘 작동

**Out-of-order execution, 비순차 실행**
프로그램 실행 과정에서 이전 작업 결과에 의존하지 않는 부분을 찾아내서 두 작업을 순서에 관계없이 실행하거나 혹은 동시에 실행하는 기법
- 한 명령이 메모리에서 데이터를 가져오는 등의 이유로 대기하는 동안에 다른 명령을 실행할 수 있도록 함
- 사용 가능한 자원을 최대한 활용할 수 있게 만듦

**Multicore architecture, 멀티코어 아키텍처의 보급**
하나의 실행 유닛에 여러 개의 CPU를 두어 전체적인 처리량이 단일 CPU의 처리량을 능가하도록 함
- 초당 처리할 수 있는 전체 연산의 수를 늘려주지만 _모든 연산 유닛을 동시에 제대로 활용하기는 쉽지 않다._
- **Amdahl's law**: 멀티코어에서 작동하도록 설계된 프로그램일지라도 하나의 코어에서 실행되어야 하느 루틴이 존재, 이 루틴이 더 많은 코어를 투입했을 때 기대할 수 있는 최대 성능 향상치의 병목으로 작용한다
- 특정 코어가 작업을 끝내는 데 걸리는 시간이 병목이 되는 지점까지는 코어 수를 늘릴수록 성능을 더 끌어올릴 수 있다.

In Python, **GIL(Global Interpreter Lock), 전역 인터프리터 락)** 때문에 여러 개의 코어를 활용하기가 어려움
- GIL은 현재 사용 중인 코어가 몇 개든, 한 번에 하나의 명령만 실행되도록 강제
- 이는 `multiprocessing` 모듈 사용 / `numexpr`, `Cython` 같은 기술을 이용하거나 / 아니면 `분산 컴퓨팅 모델`을 사용하는 방법으로 회피가능

### [기억 장치](https://namu.wiki/w/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98)
메모리란 컴퓨터의 기억장치를 일컫음
컴퓨터에서 기억장치는 비트를 저장
비트는 프로그램 내의 변수를 나타내거나 그림의 픽셀을 나타낼 수 있음
기억 장치에는 메인보드의 레지스터, RAM, 하드디스크도 포함

**읽기/쓰기 속도**
대부분의 기억장치는 (1)데이터를 조금씩 자주 읽을 때보다 (2)한꺼번에 많이 읽을 때 훨씬 빠르게 작동
(1)은 `random access`, 임의 접근
(2)는 `sequential access`, 순차 접근

**지연 시간**
장치에서 데이터를 찾기까지 걸리는 시간

``하드디스크 < SSD(Solid State Drive) < RAM < L1/L2 cache``

속도와 용량은 Trade-Off 관계

### 통신 계층
다양한 통신계층이 존재, 모두 **bus** 의 변형들

FSB(frontsize bus): RAM과 L1/L2 cache를 연결
- 처리할 준비가 된 데이터를 옮겨서 프로세서가 계산할 수 있도록 함
- 계산이 완료되면 return

GPU를 사용하는 가장 큰 걸림돌이 **bus**
- 일반적인 FSB가 아닌 훨씬 느린 PCI 버스로 연결 (왜? 주변장치이므로)
- **heterogeneous computing** 혹은 CPU와 GPU를 FSB로 연결한 시스템의 출현은 이런 것을 극복하기 위한 것

컴퓨터 내부 / 외부의 정보 통신 중요
- 네트워크 통신은 훨씬 유연
- NAS(Network attached storage)같은 기억 장치와 바로 연결 혹은
- 클러스터의 컴퓨팅 노드같은 다른 컴퓨팅 블록과 연결될 수 있음
- 아주아주아주 느림

버스의 주요한 속성은 **주어진 시간에 얼마나 많은 데이터를 전송할 수 있는지**
- (1) 버스 폭(width): 한 번에 전송할 수 있는 데이터의 양
- (2) 버스 주파수(frequency): 초당 몇 번을 전송할 수 있는지

한 번의 전송으로 데이터를 옮기는 과정은 **순차적**

버스 폭이 넓다 -> 한 번에 옮길 수 있다 -> 코드를 벡터화할 수 있다

버스 주파수가 높다 -> 임의의 메모리 영역을 자주 읽어야 하는 경우 도움이 된다

## 1.2 기본 구성 함께 보기
컴퓨터의 기본적인 구성 요소가 아우러져 훨씬 복잡한 문제를 야기한다.

성능에 관해 파이썬은 태생적으로 부족한가? Nope!
- (1) 성능을 좌우하면 아주 중요한 구성 요소인 **개발자** 를 고려하지 않았다.
- (2) 성능 문제를 비교적 쉽게 완화할 수 있는 모듈과 철학을 소개할 것

### 이상적인 컴퓨팅 vs 파이썬 가상 머신

```Python
import math
def check_prime(number):
    sqrt_number = math.sqrt(number)
    number_float = float(number)
    for i in range(2, int(sqrt_number)+1):
        if (number_float / i).is_integer():
          return False
    return True
```

**이상적인 컴퓨팅**
```
- 수가 RAM에 저장
- sqrt_number, number_float를 계산하기 위해 이 값을 CPU로 보냄
- 이 값은 한 번에 전송, CPU의 L1/L2 cache에 저장
- CPU가 계산한 결과를 다시 RAM으로 되돌려줌
```
- 위 경우는 RAM에서 수를 읽는 횟수를 최소화하고 수를 RAM보다 훨씬 빠른 L1/L2 캐시에서 읽어오게끔 함
- FSB를 통한 데이터 전송 횟수를 최소화, CPU와 여러 캐시를 잇는 좀 더 빠른 BSB를 선택
- **heavy** 라는 개념은 데이터를 옮기는 데 시간과 노력이 필요하다는 사실을 의미

앞 코드의 loop에서 number_float과 i값 여러 개를 동시에 검사하도록 만들자.
- 주석으로 써놨지만, 아래 코드는 유효한 파이썬 코드가 아니다.

```Python
import math
def check_prime(number):
    sqrt_number = math.sqrt(number)
    number_float = float(number)
    numbers = range(2, int(sqrt_number)+1)
    for i in range(0, len(numbers), 5):
        # 아래 파이썬 코드는 유효한 코드가 아니다!
        result = (number_float / numbers[i:(i+5)]).is_integer() # CPU 벡터화 연산
        if any(result):
          return False
    return True
```

**파이썬 가상 머신**
파이썬 인터프리터는 컴퓨터의 구성 요소를 **추상화** 해둠.
따라서, (1) 배열을 위한 메모리 할당, (2) 메모리 정렬, (3) CPU로 데이터를 보내는 순서 등을 개발자가 고민할 필요가 없게끔 함.
이게 과연 편리하기만 할까? 여기에는 엄청난 성능상의 비용을 지불해야 한다.

위 예제가 왜 유요한 파이썬 코드가 아닐까? **python에선 실수를 list로 나눌 수 없다!**

#### 파이썬의 추상화는 다음 계산에 사용할 데이터를 L1/L2 캐시에 유지해야 하는 최적화에 방해된다!
1. **파이썬 객체가 메모리에 최적화된 형태로 저장되지 않는다**
- 파이썬은 메모리를 자동으로 할당하고 해제하는 `garbage collector, GC`를 사용
- 이는 CPU 캐시에 데이터를 전송하는 데 영향을 미치는 **메모리 단편화** 를 야기
- 게다가 어디에서도 메모리에 저장되는 데이터 구조를 직접 변경할 수 없기 때문에
- 심지어 버스 폭이 충분히 넓더라도 한 번의 계산에 필요한 정보를 한 번에 직접 전송 불가능

2. **파이썬은 동적 타입을 사용, 컴파일되지 않는다.**
- 정적인 코드라면 컴파일러는 최적화를 통해 많은 부분을 변경 가능
- CPU가 특정 명령을 어떻게 실행시킬지도 변경 가능
- 하지만 파이썬은 컴파일되지 않고 코드의 기능이 런타임에 변경되는 동적 타입 언어
- 즉, 최적화 알고리즘이 제 기능을 발휘하기 어려움
- 이 문제를 극복할 대표적인 방법이 `Cython`을 활용하는 것

3. **GIL(Global Interpreter Lock)**
- loop을 여러 개의 core에 분산 처리한다고 가정하자.
- GIL때문에 동시에 사용할 수 있는 코어는 몇 개든 1개 뿐이다.
- 즉, 결과적으로는 코드를 변경핮기 전과 동일하게 작동하며 루프를 일찍 끝내지도 못한다.
- 이 문제는 **멀티쓰레드** 가 아닌 **멀티프로세스** (`multiprocessing` 모듈)로 극복 가능하다!
- `Cython`이나 외부 함수(foreign function)으로도 회피 가능하다.

아니 근데 GPU 병렬처리하면 끝 아님? 굳이?
- GPU와 CPU간 버스 문제도 있고
- 실제로 전처리나 시간 중 90%를 할애할 작업은 CPU에서 진행한다
- 게다가 interpreter는 태생적으로 느리기 때문에 이를 극복할 방법을 모색해야 하는 것이지.

## 1.3 파이썬을 쓰는 이유
파이썬은 표현력이 좋고 배우기가 쉬움

파이썬의 주된 장점 중 하나는 **프로토타이핑**
- 처음부터 그럴싸하지는 않더라도 다양한 라이브러리를 활용, 실현 가능한 아이디어인지 빠르게 검증 가능
- 제대로된 이해없ㄴ이 어설픈 최적화를 시도하면 결과적으로 팀을 문제에 빠뜨릴 뿐이다.


## 공부할 단어들
- backside bus, BSB
- frontside bus, FSB
- QuickPath Interconnect, QPI
- L1, L2 cache
- 트랜지스터
