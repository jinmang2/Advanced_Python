# High Performance Python

<img src="https://tensorflowkorea.files.wordpress.com/2016/05/high_performance_python.png?w=700&h=" width="50%" height="50%">

## CONTENTS

### CHAPTER 1. 고성능을 위한 파이썬 이해하기
```
1.1 컴퓨터 시스템의 기본
- 연산 장치
- 기억 장치
- 통신 계층

1.2 기본 구성 함께 보기
- 이상적인 컴퓨팅 VS 파이썬 가상 머신

1.3 파이썬을 쓰는 이유
```

### CHAPTER 2. 프로파일링으로 병목 지점 찾기
```
2.1 효과적으로 프로파일링하기

2.2 쥘리아 집합

2.3 전체 쥘리아 집합 계산하기

2.4 시간을 측정하는 간단한 방법 - print와 데코레이터

2.5 유닉스 time 명령어를 이용한 간단한 시간 측정

2.6 cProfile 모듈 활용하기

2.7 line_profiler로 한 줄씩 측정하기

2.8 memory_profiler로 메모리 사용량 진단하기

2.9 heapy로 힙 메모리 살펴보기

2.10 dowser로 변수 생성을 실시간으로 확인하기

2.11 dis 모듈로 CPython의 바이트코드 조사하기 
- 방식에 따른 복잡도

2.12 최적화 중에 단위 테스트하기
- no-op @profile 데코레이터

2.13 성공적인 코드 프로파일링 전략
```

### CHAPTER 3. 리스트와 튜플
```
3.1 더 효율적인 탐색

3.2 리스트와 튜플
- 리스트: 동적 배열
- 튜플: 정적 배열

### CHAPTER 4. 사전과 셋
4.1 사전과 셋의 동작 원리
- 삽입과 검색
- 삭제
- 크기 변경
- 해시 함수와 엔트로피

4.2 사전과 네임스페이스
```

### CHAPTER 5. 이터레이터와 제너레이터
```
5.1 무한급수와 이터레이터

5.2 제너레이터의 지연 실행
```

### CHAPTER 6. 행렬과 벡터 연산
```
6.1 문제 소개

6.2 파이썬의 리스트만으로 충분할까?
- 너무 잦은 할당에 대한 문제

6.3 메모리 단편화
- perf 이해하기
- perf 결과 반영하기
- numpy 입문

6.4 numpy를 이용한 확산 방정식 해법
- 메모리 할당과 제자리 연산
- 선택적 최적화: 고칠 부분 찾기

6.5 numexpr: 제자리 연산을 더 빠르고 간편하게 쓰기

6.6 최적화 검증 scipy
```
